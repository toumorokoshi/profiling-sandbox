// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum CategoryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Category<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Category<'a> {
  type Inner = Category<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Category<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Category { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CategoryArgs<'args>
  ) -> flatbuffers::WIPOffset<Category<'bldr>> {
    let mut builder = CategoryBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Category::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Category::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Category<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct CategoryArgs<'a> {
    pub id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CategoryArgs<'a> {
  #[inline]
  fn default() -> Self {
    CategoryArgs {
      id: 0,
      name: None,
    }
  }
}

pub struct CategoryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CategoryBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Category::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Category::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CategoryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CategoryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Category<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Category<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Category");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum TrackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Track<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Track<'a> {
  type Inner = Track<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Track<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CATEGORY_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Track { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TrackArgs<'args>
  ) -> flatbuffers::WIPOffset<Track<'bldr>> {
    let mut builder = TrackBuilder::new(_fbb);
    builder.add_category_id(args.category_id);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Track::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Track::VT_NAME, None)}
  }
  #[inline]
  pub fn category_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Track::VT_CATEGORY_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Track<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u32>("category_id", Self::VT_CATEGORY_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct TrackArgs<'a> {
    pub id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub category_id: u32,
}
impl<'a> Default for TrackArgs<'a> {
  #[inline]
  fn default() -> Self {
    TrackArgs {
      id: 0,
      name: None,
      category_id: 0,
    }
  }
}

pub struct TrackBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TrackBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Track::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Track::VT_NAME, name);
  }
  #[inline]
  pub fn add_category_id(&mut self, category_id: u32) {
    self.fbb_.push_slot::<u32>(Track::VT_CATEGORY_ID, category_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TrackBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TrackBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Track<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Track<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Track");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("category_id", &self.category_id());
      ds.finish()
  }
}
pub enum SpanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Span<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Span<'a> {
  type Inner = Span<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Span<'a> {
  pub const VT_TRACK_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_START_TIME_NS: flatbuffers::VOffsetT = 8;
  pub const VT_END_TIME_NS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Span { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpanArgs<'args>
  ) -> flatbuffers::WIPOffset<Span<'bldr>> {
    let mut builder = SpanBuilder::new(_fbb);
    builder.add_end_time_ns(args.end_time_ns);
    builder.add_start_time_ns(args.start_time_ns);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_track_id(args.track_id);
    builder.finish()
  }


  #[inline]
  pub fn track_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Span::VT_TRACK_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Span::VT_NAME, None)}
  }
  #[inline]
  pub fn start_time_ns(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Span::VT_START_TIME_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn end_time_ns(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Span::VT_END_TIME_NS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Span<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("track_id", Self::VT_TRACK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i64>("start_time_ns", Self::VT_START_TIME_NS, false)?
     .visit_field::<i64>("end_time_ns", Self::VT_END_TIME_NS, false)?
     .finish();
    Ok(())
  }
}
pub struct SpanArgs<'a> {
    pub track_id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub start_time_ns: i64,
    pub end_time_ns: i64,
}
impl<'a> Default for SpanArgs<'a> {
  #[inline]
  fn default() -> Self {
    SpanArgs {
      track_id: 0,
      name: None,
      start_time_ns: 0,
      end_time_ns: 0,
    }
  }
}

pub struct SpanBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpanBuilder<'a, 'b> {
  #[inline]
  pub fn add_track_id(&mut self, track_id: u32) {
    self.fbb_.push_slot::<u32>(Span::VT_TRACK_ID, track_id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Span::VT_NAME, name);
  }
  #[inline]
  pub fn add_start_time_ns(&mut self, start_time_ns: i64) {
    self.fbb_.push_slot::<i64>(Span::VT_START_TIME_NS, start_time_ns, 0);
  }
  #[inline]
  pub fn add_end_time_ns(&mut self, end_time_ns: i64) {
    self.fbb_.push_slot::<i64>(Span::VT_END_TIME_NS, end_time_ns, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpanBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Span<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Span<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Span");
      ds.field("track_id", &self.track_id());
      ds.field("name", &self.name());
      ds.field("start_time_ns", &self.start_time_ns());
      ds.field("end_time_ns", &self.end_time_ns());
      ds.finish()
  }
}
pub enum EventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Event<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Event<'a> {
  type Inner = Event<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Event<'a> {
  pub const VT_TRACK_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_TIME_NS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Event { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EventArgs<'args>
  ) -> flatbuffers::WIPOffset<Event<'bldr>> {
    let mut builder = EventBuilder::new(_fbb);
    builder.add_time_ns(args.time_ns);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_track_id(args.track_id);
    builder.finish()
  }


  #[inline]
  pub fn track_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Event::VT_TRACK_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Event::VT_NAME, None)}
  }
  #[inline]
  pub fn time_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Event::VT_TIME_NS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Event<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("track_id", Self::VT_TRACK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u64>("time_ns", Self::VT_TIME_NS, false)?
     .finish();
    Ok(())
  }
}
pub struct EventArgs<'a> {
    pub track_id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub time_ns: u64,
}
impl<'a> Default for EventArgs<'a> {
  #[inline]
  fn default() -> Self {
    EventArgs {
      track_id: 0,
      name: None,
      time_ns: 0,
    }
  }
}

pub struct EventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventBuilder<'a, 'b> {
  #[inline]
  pub fn add_track_id(&mut self, track_id: u32) {
    self.fbb_.push_slot::<u32>(Event::VT_TRACK_ID, track_id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_NAME, name);
  }
  #[inline]
  pub fn add_time_ns(&mut self, time_ns: u64) {
    self.fbb_.push_slot::<u64>(Event::VT_TIME_NS, time_ns, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Event<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Event<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Event");
      ds.field("track_id", &self.track_id());
      ds.field("name", &self.name());
      ds.field("time_ns", &self.time_ns());
      ds.finish()
  }
}
pub enum ProfileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Profile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Profile<'a> {
  type Inner = Profile<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Profile<'a> {
  pub const VT_CATEGORIES: flatbuffers::VOffsetT = 4;
  pub const VT_TRACKS: flatbuffers::VOffsetT = 6;
  pub const VT_EVENTS: flatbuffers::VOffsetT = 8;
  pub const VT_SPANS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Profile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ProfileArgs<'args>
  ) -> flatbuffers::WIPOffset<Profile<'bldr>> {
    let mut builder = ProfileBuilder::new(_fbb);
    if let Some(x) = args.spans { builder.add_spans(x); }
    if let Some(x) = args.events { builder.add_events(x); }
    if let Some(x) = args.tracks { builder.add_tracks(x); }
    if let Some(x) = args.categories { builder.add_categories(x); }
    builder.finish()
  }


  #[inline]
  pub fn categories(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Category<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Category>>>>(Profile::VT_CATEGORIES, None)}
  }
  #[inline]
  pub fn tracks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Track<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Track>>>>(Profile::VT_TRACKS, None)}
  }
  #[inline]
  pub fn events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Event<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Event>>>>(Profile::VT_EVENTS, None)}
  }
  #[inline]
  pub fn spans(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Span<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Span>>>>(Profile::VT_SPANS, None)}
  }
}

impl flatbuffers::Verifiable for Profile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Category>>>>("categories", Self::VT_CATEGORIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Track>>>>("tracks", Self::VT_TRACKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Event>>>>("events", Self::VT_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Span>>>>("spans", Self::VT_SPANS, false)?
     .finish();
    Ok(())
  }
}
pub struct ProfileArgs<'a> {
    pub categories: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Category<'a>>>>>,
    pub tracks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Track<'a>>>>>,
    pub events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Event<'a>>>>>,
    pub spans: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Span<'a>>>>>,
}
impl<'a> Default for ProfileArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProfileArgs {
      categories: None,
      tracks: None,
      events: None,
      spans: None,
    }
  }
}

pub struct ProfileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ProfileBuilder<'a, 'b> {
  #[inline]
  pub fn add_categories(&mut self, categories: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Category<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Profile::VT_CATEGORIES, categories);
  }
  #[inline]
  pub fn add_tracks(&mut self, tracks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Track<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Profile::VT_TRACKS, tracks);
  }
  #[inline]
  pub fn add_events(&mut self, events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Event<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Profile::VT_EVENTS, events);
  }
  #[inline]
  pub fn add_spans(&mut self, spans: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Span<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Profile::VT_SPANS, spans);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProfileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ProfileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Profile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Profile<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Profile");
      ds.field("categories", &self.categories());
      ds.field("tracks", &self.tracks());
      ds.field("events", &self.events());
      ds.field("spans", &self.spans());
      ds.finish()
  }
}
